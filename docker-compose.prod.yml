# ==============================================================================
# DOCKER COMPOSE PRODUCTION OVERRIDES
# ==============================================================================
# This file contains ONLY production-specific configuration differences.
# It merges with docker-compose.yml to create a secure, optimized production setup.
#
# Purpose: Remove dev features, add production optimizations, and enforce
# security best practices for running in production environments.
#
# Usage:
#   docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d
#
# This follows the Override Pattern:
# - Base file (docker-compose.yml): 90% of configuration
# - Override file (this file): 10% of production-specific differences
# ==============================================================================

# ------------------------------------------------------------------------------
# SERVICE OVERRIDES
# ------------------------------------------------------------------------------
services:
  
  # ----------------------------------------------------------------------------
  # PYTHON APPLICATION - PRODUCTION HARDENING
  # ----------------------------------------------------------------------------
  # Only specify what's DIFFERENT from base configuration
  # Focus on security, performance, and reliability
  python-app:
    
    # -------------------------------------------------------------------------
    # BUILD CONFIGURATION
    # -------------------------------------------------------------------------
    build:
      # üîÑ OVERRIDE: Use production Dockerfile instead of base
      # Dockerfile.prod:
      # - No debug tools (debugpy, pytest, etc.) ‚Üí Security
      # - Health checks enabled ‚Üí Reliability
      # - Smaller image size ‚Üí Faster deployment
      # - Runs app immediately ‚Üí No idle containers
      # Path is relative to context (./src) not to this file!
      dockerfile: Dockerfile.prod
    
    # -------------------------------------------------------------------------
    # CONTAINER NAME
    # -------------------------------------------------------------------------
    # üîÑ OVERRIDE: Add "-prod" suffix to distinguish from dev
    # This allows running dev and prod side-by-side (for testing migrations)
    container_name: python-app-prod
    
    # -------------------------------------------------------------------------
    # VOLUME MOUNTS
    # -------------------------------------------------------------------------
    # üîÑ OVERRIDE: Empty array = NO volumes mounted
    # Production uses IMMUTABLE containers:
    # - Code is baked into the image (not mounted from host)
    # - Can't accidentally modify running code
    # - Ensures all instances run identical code
    # - Better security (no host filesystem access)
    volumes: []
    
    # Why immutable containers?
    # ‚úì Consistency: All instances identical (no drift)
    # ‚úì Security: Can't modify production code at runtime
    # ‚úì Rollback: Easy to revert to previous image
    # ‚úì Scalability: Can spin up identical instances anywhere
    
    # -------------------------------------------------------------------------
    # ENVIRONMENT VARIABLES
    # -------------------------------------------------------------------------
    # ‚ö†Ô∏è Arrays are REPLACED! Must repeat base environment variables
    environment:
      # üîÑ REPEAT: From base file (required for real-time logs)
      - PYTHONUNBUFFERED=1
      # ‚ûï ADD: Explicitly disable debug mode
      # Your application should check this and disable debug features
      - DEBUG=false
      # ‚ûï ADD: Production environment marker
      # Use this for conditional logic: if os.getenv('ENV') == 'production'
      - ENV=production
    
    # Production environment variable best practices:
    # - Use secrets management (Docker Secrets, HashiCorp Vault)
    # - Never commit secrets to git
    # - Use .env files (excluded from git) for local prod testing
    # - In cloud: Use AWS Secrets Manager, Azure Key Vault, etc.
    
    # -------------------------------------------------------------------------
    # RESTART POLICY
    # -------------------------------------------------------------------------
    # üîÑ OVERRIDE: Always restart (even after manual stop)
    # Base uses "unless-stopped" (more lenient)
    # Production needs maximum uptime
    restart: always
    
    # Restart policies:
    # - no: Never restart
    # - on-failure: Restart only if exits with error
    # - unless-stopped: Restart unless manually stopped (dev default)
    # - always: Always restart, even after manual stop (prod default)
    
    # -------------------------------------------------------------------------
    # RESOURCE LIMITS
    # -------------------------------------------------------------------------
    # ‚ûï ADD: Production resource constraints
    # These are stricter and higher than development
    deploy:
      resources:
        # Maximum resources this container can use
        limits:
          cpus: '2.0'      # Max 2 CPU cores (200% of 1 core)
          memory: 1G       # Max 1 GB RAM
        # Guaranteed resources (reserved for this container)
        reservations:
          cpus: '0.5'      # Reserve 50% of 1 CPU core
          memory: 256M     # Reserve 256 MB RAM
    
    # Why set resource limits?
    # ‚úì Prevents one container from starving others
    # ‚úì Ensures predictable performance
    # ‚úì Helps with capacity planning
    # ‚úì Required for production orchestration (Kubernetes, Swarm)

  # ----------------------------------------------------------------------------
  # DEV CONTAINER - DISABLE IN PRODUCTION
  # ----------------------------------------------------------------------------
  dev-container:
    deploy:
      # üö´ DISABLE: Set replicas to 0 = service won't start
      replicas: 0

# ==============================================================================
# WHAT GETS MERGED:
# ==============================================================================
#
# When you run:
#   docker compose -f docker-compose.yml -f docker-compose.prod.yml up
#
# The final configuration for python-app service becomes:
#
# python-app:
#   build:
#     context: ./src               # From base
#     dockerfile: Dockerfile.prod   # From prod (overrides base)
#   container_name: python-app-prod # From prod (overrides base)
#   ports:
#     - "8000:8000"                # From base (not overridden)
#   volumes: []                     # From prod (overrides base, empty!)
#   environment:
#     - PYTHONUNBUFFERED=1          # From prod (replaces base array)
#     - DEBUG=false                # From prod (replaces base array)
#     - ENV=production             # From prod (replaces base array)
#   networks:
#     - app-network                # From base (not overridden)
#   depends_on:
#     - python-base                # From base (not overridden)
#   restart: always                # From prod (overrides base)
#   deploy:                        # From prod (added)
#     resources:
#       limits:
#         cpus: '2.0'
#         memory: 1G
#       reservations:
#         cpus: '0.5'
#         memory: 256M
#
# ==============================================================================
# PRODUCTION FEATURES:
# ==============================================================================
#
# ‚úì Immutable Containers: Code baked in, not mounted
# ‚úì No Debug Tools: Smaller image, more secure
# ‚úì Health Checks: Automatic recovery from failures (in Dockerfile.prod)
# ‚úì Always Restart: Maximum uptime
# ‚úì Resource Limits: Predictable performance
# ‚úì No SSH Access: dev-container disabled (replicas: 0)
# ‚úì Debug Mode Off: No debug endpoints or verbose logging
# ‚úì Higher Resources: 2 CPUs, 1GB RAM (vs dev: 1 CPU, 512MB)
#
# ==============================================================================
# PRODUCTION DEPLOYMENT CHECKLIST:
# ==============================================================================
#
# Before deploying to production:
#
# 1. Security:
#    ‚òê Secrets stored securely (not in code)
#    ‚òê HTTPS enabled (reverse proxy with TLS)
#    ‚òê Debug mode disabled
#    ‚òê Non-root user (already set in Dockerfile)
#    ‚òê Minimal attack surface (no unnecessary ports/tools)
#
# 2. Reliability:
#    ‚òê Health checks configured (already in Dockerfile.prod)
#    ‚òê Resource limits set (already in this file)
#    ‚òê Restart policy: always (already in this file)
#    ‚òê Logging configured (stdout/stderr to log aggregation)
#    ‚òê Monitoring configured (metrics, alerts)
#
# 3. Performance:
#    ‚òê Production web server (gunicorn, uvicorn, not dev server)
#    ‚òê Multiple workers configured
#    ‚òê Database connection pooling
#    ‚òê Caching enabled (Redis, Memcached)
#    ‚òê CDN for static assets
#
# 4. Scalability:
#    ‚òê Stateless containers (no local storage)
#    ‚òê Load balancer configured
#    ‚òê Horizontal scaling ready (can run multiple instances)
#    ‚òê Database can handle load
#
# 5. Operations:
#    ‚òê Backup strategy defined
#    ‚òê Disaster recovery plan
#    ‚òê Rollback plan tested
#    ‚òê CI/CD pipeline configured
#    ‚òê On-call rotation established
#
# ==============================================================================
# PRODUCTION COMMANDS:
# ==============================================================================
#
# Deploy to production:
#   docker compose -f docker-compose.yml -f docker-compose.prod.yml up -d
#
# Zero-downtime deployment:
#   docker compose -f ... -f ... up -d --no-deps --build python-app
#
# View logs:
#   docker compose -f ... -f ... logs -f python-app
#
# Check health:
#   docker ps  # Check STATUS column for "healthy"
#   docker inspect python-app-prod | grep Health -A 10
#
# Scale horizontally (run multiple instances):
#   docker compose -f ... -f ... up -d --scale python-app=3
#
# Stop:
#   docker compose -f ... -f ... down
#
# Emergency: Stop immediately (no graceful shutdown):
#   docker compose -f ... -f ... kill
#
# ==============================================================================