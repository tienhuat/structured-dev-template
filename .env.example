# ==============================================================================
# ENVIRONMENT CONFIGURATION TEMPLATE (.env.example)
# ==============================================================================
# This template provides all available configuration options with comprehensive
# documentation for both local development and production deployment patterns.
# 
# SETUP FOR LOCAL DEVELOPMENT:
#   cp .env.example .env
#   nano .env  # Edit with your configuration
#   direnv allow  # (if using direnv for auto-loading)
#
# ==============================================================================
# DEPLOYMENT ENVIRONMENTS & USAGE PATTERNS
# ==============================================================================
#
# ┌─────────────────────────────────────────────────────────────────────────────┐
# │ LOCAL DEVELOPMENT (Developer Laptops)                                      │
# └─────────────────────────────────────────────────────────────────────────────┘
# Purpose: Individual developer setup for coding, testing, and debugging
# 
# File Structure:
#   .env.example     ← Template (committed to git) - THIS FILE
#   .env            ← Your local config (gitignored - copy from .env.example)
#   .envrc          ← direnv configuration (auto-loads variables)
#
# Workflow:
#   1. cp .env.example .env
#   2. direnv allow  # Enable auto-loading
#   3. Edit .env for your local setup (database URLs, ports, etc.)
#
# Note: .env is for LOCAL DEVELOPMENT ONLY
#
# ┌─────────────────────────────────────────────────────────────────────────────┐
# │ PRODUCTION DEPLOYMENT (Servers, CI/CD, Cloud)                              │
# └─────────────────────────────────────────────────────────────────────────────┘
# Purpose: Live applications serving real users and handling real data
#
# Environment Variable Sources (NEVER use .env files in production):
#   ✅ CI/CD Pipelines     ← Jenkins, GitLab CI, GitHub Actions set env vars
#   ✅ Container Platforms ← Kubernetes deployment YAML, Docker Compose
#   ✅ Cloud Providers     ← AWS Parameter Store, Azure Key Vault, GCP Secret Manager
#   ✅ Orchestration       ← Docker Swarm secrets, Kubernetes secrets
#   ✅ Platform Services   ← Heroku config vars, Azure App Service settings
#   ❌ .env Files          ← NEVER use in production for security reasons
#
# Examples of Production Environment Variable Injection:
#
# Kubernetes (deployment.yaml):
#   env:
#     - name: APP_ENV
#       value: "prod"
#     - name: DATABASE_URL
#       valueFrom:
#         secretKeyRef:
#           name: db-secret
#           key: url
#
# Docker Compose (production):
#   environment:
#     - APP_ENV=prod
#     - DATABASE_URL=${DATABASE_URL}  # Injected by CI/CD
#
# CI/CD Pipeline (GitHub Actions):
#   env:
#     APP_ENV: prod
#     DATABASE_URL: ${{ secrets.DATABASE_URL }}
#
# AWS ECS Task Definition:
#   "environment": [
#     {"name": "APP_ENV", "value": "prod"},
#     {"name": "DATABASE_URL", "valueFrom": "arn:aws:ssm:..."}
#   ]
#
# Security Principle:
#   Production servers receive environment variables from secure, managed
#   sources - never from .env files on disk which can be accidentally
#   committed, logged, or accessed by unauthorized processes.
#
# ==============================================================================
# DIRENV INTEGRATION (Development Only)
# ==============================================================================
# direnv automatically loads environment variables when entering this directory
# Perfect for development - ensures consistent environment setup across team
#
# One-time Setup:
#   macOS:   brew install direnv && echo 'eval "$(direnv hook zsh)"' >> ~/.zshrc
#   Ubuntu:  sudo apt install direnv && echo 'eval "$(direnv hook bash)"' >> ~/.bashrc
#   
# Usage:
#   direnv allow  # Allow .envrc to run (required once per directory)
#
# File Loading:
#   .env                 ← Local development configuration
#
# ⚠️  NOTE: direnv is for DEVELOPMENT ONLY - never install on production servers
#
# ==============================================================================

# ------------------------------------------------------------------------------
# APPLICATION SETTINGS
# ------------------------------------------------------------------------------
# Application name (required)
# Used in logs, monitoring, and application identification
APP_NAME=python-dev-container

# Environment: dev, uat, stg, prod
# Controls environment-specific behavior and logging
# Override in environment-specific files (.env.dev, .env.prod, etc.)
APP_ENV=dev

# Debug mode: true or false
# Enable verbose logging and detailed error messages
# ⚠️  IMPORTANT: Set to 'false' in production!
APP_DEBUG=true

# Application port
# Port where the application listens for requests
APP_PORT=8000

# ------------------------------------------------------------------------------
# DATABASE CONFIGURATION
# ------------------------------------------------------------------------------
# Database connection string
# 
# Format examples:
#   PostgreSQL: postgresql://user:password@host:port/database
#   MySQL:      mysql://user:password@host:port/database
#   SQLite:     sqlite:///./database.db
#
# Local development default (SQLite for simplicity)
DATABASE_URL=sqlite:///./dev.db

# For local testing with PostgreSQL/MySQL:
# DATABASE_URL=postgresql://localhost:5432/myapp_dev
# DATABASE_URL=mysql://localhost:3306/myapp_dev

# ------------------------------------------------------------------------------
# EXTERNAL API CONFIGURATION
# ------------------------------------------------------------------------------
# API keys and secrets (⚠️  SENSITIVE - use .env.local or environment-specific .env.*.local)
# 
# Example placeholders:
# API_KEY=your-api-key-here
# API_SECRET=your-api-secret-here
# OPENAI_API_KEY=sk-...
# STRIPE_API_KEY=sk_test_...
# AWS_ACCESS_KEY_ID=AKIA...
# AWS_SECRET_ACCESS_KEY=...

# ⚠️  IMPORTANT: Never commit real API keys!
# - Keep .env file gitignored for sensitive values
# - Production: Use CI/CD secrets or secure vaults (see deployment guide below)

# ------------------------------------------------------------------------------
# LOGGING CONFIGURATION
# ------------------------------------------------------------------------------
# Log level: DEBUG, INFO, WARNING, ERROR, CRITICAL
# Controls verbosity of application logs
LOG_LEVEL=INFO

# Log format: json, text
# JSON format is recommended for production (easier to parse)
LOG_FORMAT=json

# ------------------------------------------------------------------------------
# FEATURE FLAGS
# ------------------------------------------------------------------------------
# Enable/disable features without code changes
# Useful for gradual rollouts and A/B testing
FEATURE_NEW_UI=false
FEATURE_BETA_API=false

# ==============================================================================
# PRODUCTION DEPLOYMENT GUIDE
# ==============================================================================
#
# ┌─────────────────────────────────────────────────────────────────────────────┐
# │ LOCAL DEVELOPMENT                                                           │
# └─────────────────────────────────────────────────────────────────────────────┘
# Use .env file (gitignored for security)
#
# ┌─────────────────────────────────────────────────────────────────────────────┐
# │ PRODUCTION ENVIRONMENTS (UAT, Staging, Production)                         │
# └─────────────────────────────────────────────────────────────────────────────┘
# Environment variables are injected by CI/CD pipelines and deployment tools.
# NEVER use .env files in production servers.
#
# Common Production Deployment Methods:
#
# 1. CI/CD Pipeline Secrets:
#    - GitHub Actions: Repository secrets → workflow environment
#    - GitLab CI: Variables → pipeline environment  
#    - Jenkins: Credentials → build environment
#    - Azure DevOps: Variable groups → pipeline
#
# 2. Cloud Platform Configuration:
#    - Heroku: Config vars (heroku config:set)
#    - Vercel: Environment variables in dashboard
#    - Netlify: Site settings → Environment variables
#    - Railway: Environment variables in dashboard
#
# 3. Container Orchestration:
#    - Kubernetes: Secrets and ConfigMaps in deployment YAML
#    - Docker Compose: External environment files
#    - AWS ECS: Task definition environment variables
#    - Azure Container Instances: Environment variables
#
# 4. Cloud Secret Management:
#    - AWS: Systems Manager Parameter Store / Secrets Manager
#    - Azure: Key Vault integration
#    - GCP: Secret Manager
#    - HashiCorp Vault
#
# Example Configuration Values by Environment:
#
# Development (local .env):
#   APP_ENV=dev, APP_DEBUG=true, DATABASE_URL=sqlite:///./dev.db
#
# Production (set by CI/CD):
#   APP_ENV=prod, APP_DEBUG=false, DATABASE_URL=postgresql://prod-server/db
#
# ==============================================================================
# QUICK START GUIDE
# ==============================================================================
#
# 🚀 GET STARTED (Local Development):
#   1. cp .env.example .env
#   2. nano .env  # Edit configuration for your setup
#   3. direnv allow  # (if using direnv)
#   4. python3 main.py  # Test your configuration
#
# 🔧 CUSTOMIZE:
#   Edit .env file directly for all local configuration:
#     APP_DEBUG=false
#     APP_PORT=8001
#     LOG_LEVEL=WARNING
#
# 🏭 PRODUCTION DEPLOYMENT:
#   - Use CI/CD pipelines to set environment variables
#   - Store secrets in secure vaults (AWS Secrets, Azure Key Vault)
#   - Never use .env files on production servers
#   - Inject variables through container orchestration or cloud platforms
#
# 🔐 SECURITY REMINDERS:
#   ✅ .env.example    ← Safe to commit (no secrets)
#   ❌ .env           ← Gitignored (your local config with sensitive data)
#   ❌ API keys       ← Keep in .env file or use secure deployment
#
# ==============================================================================
